{"version":3,"sources":["/source/wires-events.js"],"names":[],"mappings":"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","file":"wires-events.min.js","sourcesContent":["import _ from 'lodash';\nimport {Mixin} from 'wires-metal';\n\n/**\n * Regular expression used to split event strings.\n * @type {RegExp}\n */\nconst EVENT_SPLITTER = /\\s+/;\n\n/**\n * Implement fancy features of the Events API such as multiple event names\n * `\"change blur\"` and jQuery-style event maps `{change: action}` in terms of\n * the existing API.\n *\n * @private\n * @method _eventsApi\n */\nfunction _eventsApi(obj, action, name, rest) {\n  if (!name) {\n    return true;\n  }\n\n  // Handle event maps.\n  if (typeof name === 'object') {\n    for (var key in name) {\n      obj[action].apply(obj, [key, name[key]].concat(rest));\n    }\n    return false;\n  }\n\n  // Handle space separated event names.\n  if (EVENT_SPLITTER.test(name)) {\n    var names = name.split(EVENT_SPLITTER);\n    for (var i = 0, length = names.length; i < length; i++) {\n      obj[action].apply(obj, [names[i]].concat(rest));\n    }\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for\n * triggering events. Tries to keep the usual cases speedy (most internal\n * Backbone events have 3 arguments).\n *\n * @private\n * @method _triggerEvents\n */\nfunction _triggerEvents(events, args) {\n  var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n  switch (args.length) {\n    case 0: while (++i < l) { (ev = events[i]).callback.call(ev.ctx); } return;\n    case 1: while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); } return;\n    case 2: while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); } return;\n    case 3: while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); } return;\n    default: while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); } return;\n  }\n}\n\n/**\n * A module that can be mixed in to *any object* in order to provide it with\n * custom events. You may bind with `on` or remove with `off` callback functions\n * to an event; `trigger`-ing an event fires all callbacks in succession.\n *\n * ```js\n * var object = {};\n * _.extend(object, Backbone.Events);\n * object.on('expand', function(){ alert('expanded'); });\n * object.trigger('expand');\n * ```\n *\n * @public\n * @mixin Events\n */\nvar Events = new Mixin({\n\n  /**\n   * Bind an event to a `callback` function. Passing `\"all\"` will bind the\n   * callback to all events fired.\n   *\n   * @public\n   * @method on\n   */\n  on(name, callback, context) {\n    if (!_eventsApi(this, 'on', name, [callback, context]) || !callback) {\n      return this;\n    }\n\n    this._events || (this._events = {});\n\n    var events = this._events[name] || (this._events[name] = []);\n\n    events.push({\n      callback: callback,\n      context: context,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * Bind an event to only be triggered a single time. After the first time the\n   * callback is invoked, it will be removed.\n   *\n   * @public\n   * @method once\n   */\n  once(name, callback, context) {\n    if (!_eventsApi(this, 'once', name, [callback, context]) || !callback) {\n      return this;\n    }\n\n    var self = this;\n    var once = _.once(function() {\n      self.off(name, once);\n      callback.apply(this, arguments);\n    });\n\n    once._callback = callback;\n\n    return this.on(name, once, context);\n  },\n\n  /**\n   * Remove one or many callbacks. If `context` is null, removes all callbacks\n   * with that function. If `callback` is null, removes all callbacks for the\n   * event. If `name` is null, removes all bound callbacks for all events.\n   *\n   * @public\n   * @method off\n   */\n  off(name, callback, context) {\n    if (!this._events || !_eventsApi(this, 'off', name, [callback, context])) {\n      return this;\n    }\n\n    // Remove all callbacks for all events.\n    if (!name && !callback && !context) {\n      this._events = void 0;\n      return this;\n    }\n\n    var names = name ? [name] : _.keys(this._events);\n    for (var i = 0, length = names.length; i < length; i++) {\n      name = names[i];\n\n      // Bail out if there are no events stored.\n      var events = this._events[name];\n      if (!events) {\n        continue;\n      }\n\n      // Remove all callbacks for this event.\n      if (!callback && !context) {\n        delete this._events[name];\n        continue;\n      }\n\n      // Find any remaining events.\n      var remaining = [];\n      for (var j = 0, k = events.length; j < k; j++) {\n        var event = events[j];\n        if (\n          callback && callback !== event.callback &&\n          callback !== event.callback._callback ||\n          context && context !== event.context\n        ) {\n          remaining.push(event);\n        }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length) {\n        this._events[name] = remaining;\n      } else {\n        delete this._events[name];\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Trigger one or many events, firing all bound callbacks. Callbacks are\n   * passed the same arguments as `trigger` is, apart from the event name\n   * (unless you're listening on `\"all\"`, which will cause your callback to\n   * receive the true name of the event as the first argument).\n   *\n   * @public\n   * @method trigger\n   */\n  trigger(name, ...args) {\n    if (!this._events) {\n      return this;\n    }\n\n    if (!_eventsApi(this, 'trigger', name, args)) {\n      return this;\n    }\n\n    var events = this._events[name];\n    var allEvents = this._events.all;\n\n    if (events) {\n      _triggerEvents(events, args);\n    }\n\n    if (allEvents) {\n      _triggerEvents(allEvents, arguments);\n    }\n\n    return this;\n  },\n\n  /**\n   * Inversion-of-control versions of `on` and `once`. Tell *this* object to\n   * listen to an event in another object ... keeping track of what it's\n   * listening to.\n   *\n   * @public\n   * @method listenTo\n   */\n  listenTo(obj, name, callback) {\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n\n    listeningTo[id] = obj;\n\n    if (!callback && typeof name === 'object') {\n      callback = this;\n    }\n\n    obj.on(name, callback, this);\n\n    return this;\n  },\n\n  /**\n   * @public\n   * @method listenToOnce\n   */\n  listenToOnce(obj, name, callback) {\n    if (typeof name === 'object') {\n      for (var event in name) {\n        this.listenToOnce(obj, event, name[event]);\n      }\n      return this;\n    }\n\n    if (EVENT_SPLITTER.test(name)) {\n      var names = name.split(EVENT_SPLITTER);\n      for (var i = 0, length = names.length; i < length; i++) {\n        this.listenToOnce(obj, names[i], callback);\n      }\n      return this;\n    }\n\n    if (!callback) {\n      return this;\n    }\n\n    var once = _.once(function() {\n      this.stopListening(obj, name, once);\n      callback.apply(this, arguments);\n    });\n\n    once._callback = callback;\n\n    return this.listenTo(obj, name, once);\n  },\n\n  /**\n   * Tell this object to stop listening to either specific events ... or to\n   * every object it's currently listening to.\n   *\n   * @public\n   * @method stopListening\n   */\n  stopListening(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n\n    if (!listeningTo) {\n      return this;\n    }\n\n    var remove = !name && !callback;\n\n    if (!callback && typeof name === 'object') {\n      callback = this;\n    }\n\n    if (obj) {\n      (listeningTo = {})[obj._listenId] = obj;\n    }\n\n    for (var id in listeningTo) {\n      obj = listeningTo[id];\n      obj.off(name, callback, this);\n\n      if (remove || _.isEmpty(obj._events)) {\n        delete this._listeningTo[id];\n      }\n    }\n\n    return this;\n  }\n\n});\n\nexport default Events;\n"],"sourceRoot":"/source/"}